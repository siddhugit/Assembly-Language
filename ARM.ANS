Test date: 07/14/16  21:10:46 
The number of times you used the grading program is 12 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
ARM Grading System Version 4.1
Student: Last=Singh                First=Siddharth            Type=Individual          
Grading program history
   *** Grading Run.  Date: 07/14/16  16:05:28 
   *** Grading Run.  Date: 07/14/16  16:09:46 
   *** Grading Run.  Date: 07/14/16  16:13:47 
   *** Grading Run.  Date: 07/14/16  19:18:28 
   *** Grading Run.  Date: 07/14/16  19:32:05 
   *** Grading Run.  Date: 07/14/16  19:33:07 
   *** Grading Run.  Date: 07/14/16  19:43:58 
   *** Grading Run.  Date: 07/14/16  19:52:51 
   *** Grading Run.  Date: 07/14/16  19:54:07 
   *** Grading Run.  Date: 07/14/16  21:00:53 
   *** Grading Run.  Date: 07/14/16  21:03:47 
   *** Grading Run.  Date: 07/14/16  21:10:46 
Comparing your program's key.out to the expected output
Test ran correctly.
++ Grade ++   60 = Points earned for correct answers.

-> A major reason for programming in assembler is to maximize efficiency.
This can be instructions written and/or instructions executed.
Please read the section in the class notes titled Code Complexity.

We are now analyzing your source code. You will be graded on
the number of instructions you wrote to solve this problem.
The target for the number of executable instructions written is:
20 points for   0 -  38  
15 points for  39 -  42  
10 points for  43 -  46 
05 points for  47 -  50 
00 points for  51+      
Your actual counts are:
Lines ....... 138    Comments ...  78    Labels .......   7   
Directives ..   9    Variables ..   6    Executables ..  38    McCabe ..   3 
++ Grade ++   20 = Points earned for code written efficiency.  

-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0023 The program header format is adequate. 
DOCHB-1.12 Use of code block headers is adequate. 
DOCLC-0.92 Use of line comments is adequate. 
++ Grade ++   20 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++  100 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
    12  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC<6&}xC86&k~C6&juiC86&zuzC766&Zkyz&jgzk@&6=57:57<&&87@76@:<&

Building the file arm.ans for electronic submission...
;---------------------------------------------------------------------
; File:     copyfile.s
;
; Function: This program copies an ASCII file
;           It assumes the file uses CR/LF as the end of line sequence
;           - It opens an imput file named key.in
;           - It opens an output file named key.out
;           - It reads one line of text from the input file.
;           - It writes that one line to the output file then a CR LF
;           - It loops until it reaches end of file
;           - It closes the input and output file
;
; Author:   Siddharth Singh
;
; Changes:  Date        Reason
;           ----------------------------------------------------------
;           07/14/2016  Original version
;
;
;---------------------------------------------------------------------


;----------------------------------
; Software Interrupt values
;----------------------------------
         .equ SWI_Open,  0x66		;Open  a file
         .equ SWI_Close, 0x68		;Close a file
         .equ SWI_PrStr, 0x69		;Write a null-ending string
         .equ SWI_RdStr, 0x6a		;Read a string and terminate with null char
         .equ SWI_Exit,  0x11		;Stop execution
;----------------------------------

         .global   _start
         .text

_start:
;----------------------------------
; open input file
; - r0 points to the file name
; - r1 0 for input
; - the open swi is 66h
; - after the open r0 will have the file handle
;----------------------------------
		 ldr  r4, =charTbl			;r4 points to the char table
         ldr  r0, =InFileName		;r0 points to the file name
         ldr  r1, =0				;r1 = 0 specifies the file is input
         swi  SWI_Open				;open the file ... r0 will be the file handle
         mov  r6, r0				;store the file handle
;----------------------------------


;----------------------------------
; open output file
; - r0 points to the file name
; - r1 1 for output
; - the open swi is 66h
; - after the open r0 will have the file handle
;----------------------------------
         ldr  r0, =OutFileName		;r0 points to the file name
         ldr  r1, =1				;r1 = 1 specifies the file is output
         swi  SWI_Open				;open the file ... r0 will be the file handle
         mov  r7, r0				;store the file handle
;----------------------------------


;----------------------------------
; read a string from the input file
; - r0 contains the file handle
; - r1 points to the input string buffer
; - r2 contains the max number of characters to read
; - the read swi is 6ah
; - the input string will be terminated with 0
;----------------------------------
_read:								;
         mov  r0, r6				;r0 has the input file handle
         ldr  r1, =String			;r1 points to the input string
         ldr  r2, =128				;r2 has the max size of the input string
         swi  SWI_RdStr				;read a string from the input file
;----------------------------------


;----------------------------------
; Write the outputs string
;----------------------------------
_write:                           ;
         mov  r0, r7				;r0 has the output file handle
         ldr  r1, =displayString	;r1 points to the output string
         ldr  r2, =String			;r2 points to the input string
_loop:								;
         ldrb r3, [r2], #1			;get the next input byte
									; then increment the input pointer
         ldrb r5,[r4,r3]			;	
         cmp  r3, #0				;was it the null terminator
         beq  _nullFound			;write the output string
         cmp  r3, #0x1A				;if line was DOS eof then do not write CRLF
         beq  _exit					;so do next read 
         cmp r5,#'*'				;		
         strne r5, [r1],#1			;store it in the output buffer
         b    _loop					;loop
_nullFound:							;
		ldrb r1,=0					;store it in the output buffer
_finloop: 
		ldr  r1, =displayString		;r1 points to the output string
		swi  SWI_PrStr				;write the null terminated output string
		ldr  r1, =CRLF				;r1 points to the output string
		swi  SWI_PrStr				;write the null terminated output string
        bal  _read					;read the next line  
        
;----------------------------------


;----------------------------------
; Close input and output files
; Terminate the program
;----------------------------------
_exit:								;
         mov  r0, r6				;r0 has the input file handle
         swi  SWI_Close				;close the file
         mov  r0, r7				;r0 has the output file handle
         ldr  r1, = CRLF			;r1 points to the output string
		 swi  SWI_PrStr				;write the null terminated output string
         swi  SWI_Close				;close the file
         swi  SWI_Exit				;terminate the program
;----------------------------------


         .data
;----------------------------------
InFileName:		.asciz "KEY.IN"   ;Input  file name, null terminated                                 ;
String:			.skip 128          ;reserve a 128 byte string
displayString:  .skip 128   ;reserve a 128 byte string                                  ;
CRLF:			.byte 13, 10, 0    ;CR LF                                ;
OutFileName:	.asciz "KEY.OUT"  ;Output file name, null terminated
charTbl:		.ascii "******************************** ********************************ABCDEFGHIJKLMNOPQRSTUVWXYZ******ABCDEFGHIJKLMNOPQRSTUVWXYZ*****"    ;
;----------------------------------


         .end
