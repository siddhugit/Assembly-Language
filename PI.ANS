Test date: 06/26/16  02:11:32 
The number of times you used the grading program is 4 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
PI Grading System Version 4.0
Student: Last=Singh                First=Siddharth            Type=Individual          
Grading program history
       User Test.    Date: 06/25/16  22:34:20  TESTDIVX.IN  TESTOUT      
       User Test.    Date: 06/25/16  22:34:27  TESTADDX.IN  TESTOUT      
       User Test.    Date: 06/25/16  22:34:53  TESTADDX.IN  TESTOUT      
       User Test.    Date: 06/25/16  22:34:58  TESTDIVX.IN  TESTOUT      
   *** Grading Run.  Date: 06/25/16  22:35:33 
       User Test.    Date: 06/25/16  22:39:17  TESTADDX.IN  TESTOUT      
       User Test.    Date: 06/25/16  22:39:25  TESTDIVX.IN  TESTOUT      
   *** Grading Run.  Date: 06/25/16  22:39:34 
       User Test.    Date: 06/25/16  22:42:18  TESTDIVX.IN  TESTOUT      
       User Test.    Date: 06/25/16  22:42:22  TESTADDX.IN  TESTOUT      
   *** Grading Run.  Date: 06/25/16  22:42:29 
       User Test.    Date: 06/26/16  02:10:53  TESTADDX.IN  TESTOUT      
       User Test.    Date: 06/26/16  02:11:02  TESTDIVX.IN  TESTOUT      
   *** Grading Run.  Date: 06/26/16  02:11:32 

PI has been calculated to be ...

3.14159265358979323846264338327950288419716939937510
  58209749445923078164062862089986280348253421170679
  82148086513282306647093844609550582231725359408128
  48111745028410270193852110555964462294895493038196
  44288109756659334461284756482337867831652712019091
  45648566923460348610454326648213393607260249141273
  
++ Grade ++   50 = Points earned for correct answers.

ADDX was called this number of times: 00226
DIVX was called this number of times: 00904
The list being used has 151 data words.

Your executed instruction count = 00545112

++ Grade ++   30 = Points earned for code written efficiency.

The target for executed instructions is:
30 = 0,000,000 - 0,600,000 
25 = 0,600,001 - 0,700,000 
20 = 0,700,001 - 0,800,000 
15 = 0,800,001 - 0,900,000 
10 = 0,900,001 - 1,000,000 
 5 = 1,000,001 - 1,100,000 
 0 = 1,100,001 +           


-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0015 The program header format is adequate. 
DOCHB-0.59 Use of code block headers is adequate. 
DOCLC-0.87 Use of line comments is adequate. 
++ Grade ++   20 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++  100 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
    10  = Number of user tests.                                  
     4  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC;6&}xC96&k~C6&juiC86&zuzC766&Zkyz&jgzk@&6<58<57<&&68@77@98&

Building the file pi.ans for electronic submission...

;---------------------------------------------------------------------
;   Program:     **MASM** version of extend.asm (which is used to calculate PI)
;
;   Function:    This file contains subroutines that perform
;                extended precision arithmetic.
;                addx - extended precision addition
;                divx - extended precision division
;
;   Owner: Siddharth Singh
;
;   Date			Reason
;   ----			------
;   06/25/2016		Original version
;
;---------------------------------------------------------------------
         .model    small               ;64k code and 64k data
         .8086                         ;only allow 8086 instructions
         public    addx                ;allow linker to access addx
         public    divx                ;allow linker to access divx
;--------------------------------------

;--------------------------------------
;   ADDX Subroutine
;--------------------------------------
         .data
;--------------------------------------
;   ADDX Subroutine data section
;--------------------------------------
addtbl	dw	add_0,add_1,add_2,add_3,add_4,add_5,add_6,add_7,add_8,add_9	; add jump table

;--------------------------------------
;   ADDX Subroutine code section
;--------------------------------------
         .code
;---------------------------------------
; data segment has add jump table  
; unrolling on 10 word length  
; and adding with carry from LSW to MSW
;---------------------------------------
addx:                               ; addx subroutine
	push ax							; save ax on stack
	push bx							; save bx on stack
	push cx							; save cx on stack
	push si							; save si on stack
	push di							; save di on stack
;---------------------------------------
; cx stores unrolling information  
;---------------------------------------
	mov ax,[si]						; cx stores number of words in the list
	mov bx,ax						;
	add bx,bx						;
	mov cl,10						;
	div cl							;
	mov ch,ah						;
;---------------------------------------
; move to end of list 
;---------------------------------------
	add ch,ch						;
	mov cl,al						;
	lea si,[si + bx]				; move from lsw to msw
	lea di,[di + bx]				; move from lsw to msw
;---------------------------------------
; cx jump to corresponding unrolling handler  
;---------------------------------------
	mov bl,ch						;
	and bx,00ffh					;
	jmp word ptr[addtbl + bx]		;
;---------------------------------------
; unrolling from 9th word  
;---------------------------------------
add_9:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	lea si,[si - 2]					; move from lsw to msw
	lea di,[di - 2]					; move from lsw to msw
;---------------------------------------
; unrolling from 8th word  
;---------------------------------------
add_8:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	lea si,[si - 2]					; move from lsw to msw
	lea di,[di - 2]					; move from lsw to msw
;---------------------------------------
; unrolling from 7th word  
;---------------------------------------
add_7:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	lea si,[si - 2]					; move from lsw to msw
	lea di,[di - 2]					; move from lsw to msw
;---------------------------------------
; unrolling from 6th word  
;---------------------------------------
add_6:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	lea si,[si - 2]					; move from lsw to msw
	lea di,[di - 2]					; move from lsw to msw
;---------------------------------------
; unrolling from 5th word  
;---------------------------------------
add_5:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	lea si,[si - 2]					; move from lsw to msw
	lea di,[di - 2]					; move from lsw to msw
;---------------------------------------
; unrolling from 4th word  
;---------------------------------------
add_4:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	lea si,[si - 2]					; move from lsw to msw
	lea di,[di - 2]					; move from lsw to msw
;---------------------------------------
; unrolling from 3rd word  
;---------------------------------------
add_3:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	lea si,[si - 2]					; move from lsw to msw
	lea di,[di - 2]					; move from lsw to msw
;---------------------------------------
; unrolling from 2nd word  
;---------------------------------------
add_2:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	lea si,[si - 2]					; move from lsw to msw
	lea di,[di - 2]					; move from lsw to msw
;---------------------------------------
; unrolling from 1st word  
;---------------------------------------
add_1:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	lea si,[si - 2]					; move from lsw to msw
	lea di,[di - 2]					; move from lsw to msw
;---------------------------------------
; unrolling 10 words at a time in a loop 
;---------------------------------------
add_0:
	and cx,00ffh					;
	cmp cx,0						;
	je add_done						;
;---------------------------------------
; unrolling on 10 word length  
;---------------------------------------
add_10Loop:
	mov ax,[si]						; load content of si into ax
	adc [di],ax						; add with carry and store result into memory pointed by di
	mov ax,[si - 2]					; load content of si into ax
	adc [di - 2],ax					; add with carry and store result into memory pointed by di
;---------------------------------------
; keep adding upto 10 words  
;---------------------------------------
	mov ax,[si - 4]					; load content of si into ax
	adc [di - 4],ax					; add with carry and store result into memory pointed by di
	mov ax,[si - 6]					; load content of si into ax
	adc [di - 6],ax					; add with carry and store result into memory pointed by di
;---------------------------------------
; keep adding upto 10 words  
;---------------------------------------
	mov ax,[si - 8]					; load content of si into ax
	adc [di - 8],ax					; add with carry and store result into memory pointed by di
	mov ax,[si - 10]				; load content of si into ax
	adc [di - 10],ax				; add with carry and store result into memory pointed by di
;---------------------------------------
; keep adding upto 10 words  
;---------------------------------------
	mov ax,[si - 12]				; load content of si into ax
	adc [di - 12],ax				; add with carry and store result into memory pointed by di
	mov ax,[si - 14]				; load content of si into ax
	adc [di - 14],ax				; add with carry and store result into memory pointed by di
;---------------------------------------
; keep adding upto 10 words  
;---------------------------------------
	mov ax,[si - 16]				; load content of si into ax
	adc [di - 16],ax				; add with carry and store result into memory pointed by di
	mov ax,[si - 18]				; load content of si into ax
	adc [di - 18],ax				; add with carry and store result into memory pointed by di
;---------------------------------------
; move to next 10 words  
;---------------------------------------
	lea si,[si - 20]				; move from lsw to msw
	lea di,[di - 20]				; move from lsw to msw
	loop add_10Loop					; loop back
;---------------------------------------
; restore registers and return 
;---------------------------------------
add_done:
	pop di							; restore di
	pop si							; restore si	
	pop cx							; restore cx
	pop bx							; restore bx
	pop ax							; restore ax
	ret								; return


;--------------------------------------
;   DIVX Subroutine
;--------------------------------------
		 .data
;--------------------------------------
;   DIVX Subroutine data section
;--------------------------------------
divtbl	dw	div_0,div_1,div_2,div_3,div_4,div_5,div_6,div_7,div_8,div_9	; div jump table
divisor dw ?

;--------------------------------------
;   DIVX Subroutine code section
;--------------------------------------															; stores divisor
         .code
;---------------------------------------
; No data segment
; data segment has div jump table  
; unrolling on 10 word length  
; storing next element into ax 
; and remainder from previous operation into dx and
; divide by the divisor
;---------------------------------------
divx:								; divx subroutine
	push ax							; save ax on stack
	push bx							; save bx on stack
	push cx							; save cx on stack
	push dx							; save dx on stack
	push si							; save si on stack
;---------------------------------------
; get number of words  
;---------------------------------------
	mov ax,[si]						; cx stores number of words in the list
	mov cl,10						;
	div cl							;
;---------------------------------------
; store unrolling information  
;---------------------------------------
	mov ch,ah						;
	add ch,ch						;
	mov cl,al						;
;---------------------------------------
; store divisor  
;---------------------------------------
	mov [divisor],dx				; bx stores the divisor
	mov dx,0						; dx is initialized to zero for convenience
	mov bl,ch						;
	and bx,00ffh					;
	jmp word ptr[divtbl + bx]		;
;---------------------------------------
; unrolling from 9th word  
;---------------------------------------		
div_9:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
	lea si,[si + 2]					; go to next word in the list
;---------------------------------------
; unrolling from 8th word  
;---------------------------------------
div_8:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
	lea si,[si + 2]					; go to next word in the list
;---------------------------------------
; unrolling from 7th word  
;---------------------------------------
div_7:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
	lea si,[si + 2]					; go to next word in the list
;---------------------------------------
; unrolling from 6th word  
;---------------------------------------
div_6:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
	lea si,[si + 2]					; go to next word in the list
;---------------------------------------
; unrolling from 5th word  
;---------------------------------------
div_5:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
	lea si,[si + 2]					; go to next word in the list
;---------------------------------------
; unrolling from 4th word  
;---------------------------------------
div_4:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
	lea si,[si + 2]					; go to next word in the list
;---------------------------------------
; unrolling from 3rd word  
;---------------------------------------
div_3:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
	lea si,[si + 2]					; go to next word in the list
;---------------------------------------
; unrolling from 2nd word  
;---------------------------------------
div_2:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
	lea si,[si + 2]					; go to next word in the list
;---------------------------------------
; unrolling from 1st word  
;---------------------------------------
div_1:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
	lea si,[si + 2]					; go to next word in the list
;---------------------------------------
; unrolling 10 words at a time in a loop 
;---------------------------------------
div_0:
	and cx,00ffh					;
	cmp cx,0						;
	je div_done						;
;---------------------------------------
; unrolling on 10 word length  
;---------------------------------------
div_10Loop:
	mov ax,[si + 2]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 2],ax					; store quotient into output
;---------------------------------------
; keep dividing upto 10 words  
;---------------------------------------	
	mov ax,[si + 4]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 4],ax					; store quotient into output
	mov ax,[si + 6]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 6],ax					; store quotient into output
;---------------------------------------
; keep dividing upto 10 words  
;---------------------------------------
	mov ax,[si + 8]					; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 8],ax					; store quotient into output
	mov ax,[si + 10]				; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 10],ax				; store quotient into output
;---------------------------------------
; keep dividing upto 10 words  
;---------------------------------------
	mov ax,[si + 12]				; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 12],ax				; store quotient into output
	mov ax,[si + 14]				; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 14],ax				; store quotient into output
;---------------------------------------
; keep dividing upto 10 words  
;---------------------------------------
	mov ax,[si + 16]				; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 16],ax				; store quotient into output
	mov ax,[si + 18]				; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 18],ax				; store quotient into output
;---------------------------------------
; move to next 10 words  
;---------------------------------------
	mov ax,[si + 20]				; store next word into ax, dx stores remainder from previous operation
	div [divisor]					; divide dx:ax by the divisor
	mov [si + 20],ax				; store quotient into output
	lea si,[si + 20]				; go to next word in the list
	loop	div_10Loop				; loop back
;---------------------------------------
; restore registers and return 
;---------------------------------------
div_done:						
	pop si							; restore si
	pop dx							; restore dx
	pop cx							; restore cx
	pop bx							; restore bx
	pop ax							; restore ax
	ret								; return
;--------------------------------------
; End of file 
;---------------------------------------
         end
