Test date: 06/28/16  20:05:50 
The number of times you used the grading program is 1 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
Linkhll Grading System Version 4.0
Student: Last=Singh                First=Siddharth            Type=Individual          
Grading and testing history log
       User Test.    Date: 06/28/16  20:05:27  user_test    testout      
   *** Grading Run.  Date: 06/28/16  20:05:50 

++ Grade ++   60 = Points earned for correct answers.

+  Your executed instruction count per call is = 00018
+   
+  Target instructions executed per call is:
+  20 points 01 - 18 
+  15 points 19 - 20 
+  10 points 21 - 22 
+   5 points 23 - 24 
+   0 points 25+      
+                     
++ Grade ++   20 = Points earned for code executed efficiency!

-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0018 The program header format is adequate. 
DOCHB-0.92 Use of code block headers is adequate. 
DOCLC-1.00 Use of line comments is adequate. 
++ Grade ++   20 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++  100 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
     1  = Number of user tests.                                  
     1  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC<6&}xC6&k~C86&juiC86&zuzC766&Zkyz&jgzk@&6<58>57<&&86@6;@;6&

Building the file linkhll.ans for electronic submission...

;--------------------------------------------------------------------
;   Program:  LINKASM (MASM version)
;
;   Function: Implements a subroutine which receives four
;	word sized unsigned arguments on stack, find two largest numbers, 
;	multiply them and stores 32-bit result on dx:ax combination.
;   Algorithm: Initialize ax with val1 and cx with val2.
;	ax stores largest number and cx the second largest.
;	Hence swap ax and cx if val2 is greater than val1.
;	Go through each argument and keep updating ax and cx
;   such that the invariant is maintained. 
;
;   Owner:    Siddharth Singh
;
;   Date:			Changes
;   06/28/2016		original version
;
;---------------------------------------
         .model    small               ;
         .8086                         ;
         public    _linkhll            ;
;---------------------------------------

;---------------------------------------
;
; Code Segment
;
;---------------------------------------
         .code
;---------------------------------------
;
; stores larges value in ax and second
; largest in cx.
;
;---------------------------------------
_linkhll:								;
        push bp                         ; save bp
		mov bp,sp						; set bp to stack pointer
		mov ax,[bp + 4]					; ax = val1
		mov cx,[bp + 6]					; ax = val2
;---------------------------------------
;
; swap if cx > ax
;
;---------------------------------------
		cmp ax,cx						; compare ax and cx
		jae nxt1						; skip if ax is greater
		xchg ax,cx						; swap otherwise
;---------------------------------------
;
; if (val3 > ax)
;	ax = val3
;	cx = ax
;
;---------------------------------------
nxt1:
		cmp ax,[bp + 8]					; compare ax and val3
		jae nxt2						; skip to nxt2
		mov cx,ax						; cx = ax
		mov ax,[bp + 8]					; ax = val3
		jmp nxt3						; skip to next element
;---------------------------------------
;
; else if (val3 > cx)
;	cx = val3
;
;---------------------------------------
nxt2:
		cmp cx,[bp + 8]					; compare cx and val3
		jae nxt3						; skip to next element
		mov cx,[bp + 8]					; cx = val3 otherwise
;---------------------------------------
;
; if (val4 > ax)
;	ax = val4
;	cx = ax
;
;---------------------------------------
nxt3:
		cmp ax,[bp + 10]				; compare ax and val4
		jae nxt4						; skip to nxt4
		mov cx,ax						; cx = ax
		mov ax,[bp + 10]				; ax = val4
		jmp nxt5						; skip to multiply
;---------------------------------------
;
; else if (val4 > cx)
;	cx = val4
;
;---------------------------------------
nxt4:
		cmp cx,[bp + 10]				; compare cx and val3
		jae nxt5						; skip to multiply
		mov cx,[bp + 10]				; cx = val4 otherwise
;---------------------------------------
;
; multiply ax,cx
;
;---------------------------------------
nxt5:
		mul cx							; multiply
		pop bp							; resore bp
         ret							; return
										;
         end							; end of file
;---------------------------------------

