Test date: 06/30/16  14:04:26 
The number of times you used the grading program is 8 
In the business world, your customer replaces the grading program. 
The goal is a correct program with the fewest grading attempts. 
Multiply Grading System Version 4.0
Student: Last=Singh                First=Siddharth            Type=Individual          
Grading and testing history log
       User Test.    Date: 06/30/16  13:12:14  user_test    testout      
       User Test.    Date: 06/30/16  13:15:13  user_test    testout      
       User Test.    Date: 06/30/16  13:15:57  user_test    testout      
       User Test.    Date: 06/30/16  13:16:08  user_test    testout      
   *** Grading Run.  Date: 06/30/16  13:16:58 
       User Test.    Date: 06/30/16  13:18:16  user_test    testout      
   *** Grading Run.  Date: 06/30/16  13:18:20 
       User Test.    Date: 06/30/16  13:20:31  user_test    testout      
   *** Grading Run.  Date: 06/30/16  13:20:34 
       User Test.    Date: 06/30/16  13:21:53  user_test    testout      
   *** Grading Run.  Date: 06/30/16  13:21:56 
       User Test.    Date: 06/30/16  13:47:44  user_test    testout      
   *** Grading Run.  Date: 06/30/16  13:47:48 
       User Test.    Date: 06/30/16  13:52:03  user_test    testout      
   *** Grading Run.  Date: 06/30/16  13:52:06 
       User Test.    Date: 06/30/16  14:02:48  user_test    testout      
   *** Grading Run.  Date: 06/30/16  14:02:50 
       User Test.    Date: 06/30/16  14:04:23  user_test    testout      
   *** Grading Run.  Date: 06/30/16  14:04:26 

++ Grade ++   40 = Points earned for correct answers.

+  Your executed instruction count per multiply is = 00080
+   
+  Target instructions executed per multiply is:
+  40 points 0000 - 0085 
+  35 points 0086 - 0090 
+  30 points 0091 - 0095 
+  25 points 0096 - 0100 
+  20 points 0101 - 0105 
+  15 points 0106 - 0110 
+  10 points 0111 - 0115 
+   5 points 0116 - 0120 
+   0 points 0121 +      
+                        
++ Grade ++   40 = Points earned for code executed efficiency!

-> Analyzing program documentation. 
The heuristic algorithms used may have problems with your specific code. 
Contact the instructor if you detect a problem with your grade. 
DOCPH-0021 The program header format is adequate. 
DOCHB-0.89 Use of code block headers is adequate. 
DOCLC-1.00 Use of line comments is adequate. 
++ Grade ++   20 = Points earned for correct documentation.    

-> Calculating the total grade for the program.                  
This grade is subject to adjustment by the instructor.           
This grade will be reduced by any late submission penalty.       
++ Grade ++  100 = Total grade generated by the Grading System.  

-> Statistics on testing and grading                             
    11  = Number of user tests.                                  
     8  = Number of grading runs to get the program working.     
     0  = Number of grading runs to improve efficiency or documentation. 

+- atyC:6&}xC6&k~C:6&juiC86&zuzC766&Zkyz&jgzk@&6<59657<&&7:@6:@8<&

Building the file multiply.ans for electronic submission...

;-----------------------------------------------------------
;
; Program:  MULTIPLY
;
; Function: Multiplies two 16 bit unsigned values ...
;           .... duplicating the MUL instruction
;
; Input:    The two values to be multiplied are passed on the stack
;           The code conforms to the C/C++ calling sequence
;
; Output:   The 32 bit result is returned in the dx:ax pair
;           Registers required by C/C++ need to be saved and restored
;
; Owner:	Siddharth Singh
;
; Changes:  Date        Reason
;           ------------------
;           07/20/2013  Original version
;
;
;---------------------------------------
         .model    small
         .8086
         public    _multiply

         .data
;---------------------------------------
		carryVal dw 0					;
;---------------------------------------
;---------------------------------------
; Multiply data
;---------------------------------------


         .code
;---------------------------------------
; shift right the multiplier
; and shift left the multiplicand 
; and every time there is a carry flag in 
; shifting multiplier add multiplier into ax and
; add  carry value into dx.
;---------------------------------------
_multiply:                             
		push bp							; save bp
		mov bp,sp						; anchor bp into the stack
		mov cx,[bp+4]					; load multiplicand from the stack
		mov bx,[bp+6]					; load multiplier   from the stack
		mov carryVal,0					; carryVal used for reg,reg adc
;---------------------------------------
; loop unrolling - 1st bit
;---------------------------------------
		shr cx,1						; right shift multiplicand
		jnc processZeroBit1				; if no carry, dont add to results
		add ax,bx						; otherwise add left shifted multiplier to ax
		adc dx,[carryVal]				; and carry to dx
;---------------------------------------
; left shift multiplier and rotate
; carryVal with carry
;---------------------------------------
processZeroBit1:
		shl bx,1						; left shift multiplier
		rcl [carryVal],1				; rotate carry value with carry
;---------------------------------------
; loop unrolling - 2nd bit
;---------------------------------------
		shr cx,1						; right shift multiplicand
		jnc processZeroBit2				; if no carry, dont add to results
		add ax,bx						; otherwise add left shifted multiplier to ax
		adc dx,[carryVal]				; and carry to dx
;---------------------------------------
; left shift multiplier and rotate
; carryVal with carry
;---------------------------------------
processZeroBit2:
		shl bx,1						; left shift multiplier
		rcl [carryVal],1				; rotate carry value with carry
;---------------------------------------
; loop unrolling - 3rd bit
;---------------------------------------
		shr cx,1						; right shift multiplicand
		jnc processZeroBit3				; if no carry, dont add to results
		add ax,bx						; otherwise add left shifted multiplier to ax
		adc dx,[carryVal]				; and carry to dx
;---------------------------------------
; left shift multiplier and rotate
; carryVal with carry
;---------------------------------------
processZeroBit3:
		shl bx,1						; left shift multiplier
		rcl [carryVal],1				; rotate carry value with carry
;---------------------------------------
; loop unrolling - 4th bit
;---------------------------------------
		shr cx,1						; right shift multiplicand
		jnc processZeroBit4				; if no carry, dont add to results
		add ax,bx						; otherwise add left shifted multiplier to ax
		adc dx,[carryVal]				; and carry to dx
;---------------------------------------
; left shift multiplier and rotate
; carryVal with carry
;---------------------------------------
processZeroBit4:
		shl bx,1						; left shift multiplier
		rcl [carryVal],1				; rotate carry value with carry
;---------------------------------------
; loop unrolling - 5th bit
;---------------------------------------
		shr cx,1						; right shift multiplicand
		jnc processZeroBit5				; if no carry, dont add to results
		add ax,bx						; otherwise add left shifted multiplier to ax
		adc dx,[carryVal]				; and carry to dx
;---------------------------------------
; left shift multiplier and rotate
; carryVal with carry
;---------------------------------------
processZeroBit5:
		shl bx,1						; left shift multiplier
		rcl [carryVal],1				; rotate carry value with carry
;---------------------------------------
; loop unrolling - 6th bit
;---------------------------------------
		shr cx,1						; right shift multiplicand
		jnc processZeroBit6				; if no carry, dont add to results
		add ax,bx						; otherwise add left shifted multiplier to ax
		adc dx,[carryVal]				; and carry to dx
;---------------------------------------
; left shift multiplier and rotate
; carryVal with carry
;---------------------------------------
processZeroBit6:
		shl bx,1						; left shift multiplier
		rcl [carryVal],1				; rotate carry value with carry
;---------------------------------------
; loop unrolling - 7th bit
;---------------------------------------
		shr cx,1						; right shift multiplicand
		jnc processZeroBit7				; if no carry, dont add to results
		add ax,bx						; otherwise add left shifted multiplier to ax
		adc dx,[carryVal]				; and carry to dx
;---------------------------------------
; left shift multiplier and rotate
; carryVal with carry
;---------------------------------------
processZeroBit7:
		shl bx,1						; left shift multiplier
		rcl [carryVal],1				; rotate carry value with carry
;---------------------------------------
; loop unrolling - 8th bit
;---------------------------------------
		shr cx,1						; right shift multiplicand
		jnc processZeroBit8				; if no carry, dont add to results
		add ax,bx						; otherwise add left shifted multiplier to ax
		adc dx,[carryVal]				; and carry to dx
;---------------------------------------
; left shift multiplier and rotate
; carryVal with carry
;---------------------------------------
processZeroBit8:
		shl bx,1						; left shift multiplier
		rcl [carryVal],1				; rotate carry value with carry
;---------------------------------------
; loop for last 8 bits
;---------------------------------------
mul_loop:
		shr cx,1						; right shift multiplicand
		jnc processZeroBit				; if no carry, dont add to results
		add ax,bx						; otherwise add left shifted multiplier to ax
		adc dx,[carryVal]				; and carry to dx
;---------------------------------------
; left shift multiplier and rotate
; carryVal with carry
;---------------------------------------
processZeroBit:
		shl bx,1						; left shift multiplier
		rcl [carryVal],1				; rotate carry value with carry
		cmp cx,0						; done if remaining bits in multiplicand is zero
        jne mul_loop					; loop back
;---------------------------------------
; Clean up
;---------------------------------------
done:
         pop bp							; restore bp
         ret							; return with result in dx:ax
										;
         end							; end source code
;---------------------------------------

